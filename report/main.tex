\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{booktabs}
\usepackage{caption}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{float}

% Code listing style
\lstset{
    basicstyle=\ttfamily\small,
    breaklines=true,
    frame=single,
    backgroundcolor=\color{gray!10}
}

% Hyperlink setup
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan,
}

\title{
    \textbf{ClickHouse vs Elasticsearch:} \\
    \large A Performance Comparison for Analytical Workloads
}

\author{
    Karl Seryani (251-304-976) \\
    Arik Dhaliwal \\
    Raghav Gulati \\[0.5cm]
    \textit{COMPSCI 4411/9538} \\
    \textit{Western University}
}

\date{\today}

\begin{document}

\maketitle

\begin{abstract}
This report presents a performance comparison of ClickHouse and Elasticsearch for analytical workloads. Inspired by mpathic's migration from Elasticsearch to ClickHouse Cloud, we benchmarked both systems using healthcare datasets of 1M, 10M, and 100M rows. Our results reveal a nuanced picture: Elasticsearch's doc\_values architecture delivers 8-24x faster query performance on aggregation operations, while ClickHouse's columnar design provides superior data ingestion speeds and storage compression. Critically, ClickHouse supports SQL operations that Elasticsearch cannot perform---JOINs and subqueries---which drove mpathic's migration decision. We examine the architectural differences that drive these performance characteristics and provide guidance on when each system is appropriate.
\end{abstract}


\section{Introduction}

\subsection{Background and Motivation}

Choosing the right database system significantly impacts performance and costs, especially at scale. Mpathic, an AI healthcare startup processing thousands of hours of therapy session audio, faced this decision when their Elasticsearch-based infrastructure couldn't support their analytical needs. Their data scientists needed to run complex queries joining multiple tables for ML experimentation, but Elasticsearch fundamentally cannot perform JOINs. After migrating to ClickHouse Cloud, their pipeline execution time dropped from 15 minutes to 4 minutes \cite{mpathic2024case}.

This case study highlights a fundamental distinction in database design: the difference between \textit{query performance} and \textit{query capability}. A system may execute certain queries faster, but if it cannot execute the queries you need at all, raw speed becomes irrelevant.

\subsection{Project Objectives}

Our project has three goals:

\textbf{First}, examine the architectural differences between ClickHouse and Elasticsearch. ClickHouse uses columnar storage optimized for analytical queries and supports full SQL including JOINs and subqueries \cite{clickhouse2024architecture}. Elasticsearch uses inverted indexes with doc\_values---a columnar structure for aggregations---designed primarily for search and document retrieval \cite{elasticsearch2024docs}.

\textbf{Second}, conduct practical benchmarks on realistic healthcare data. We generated datasets with 1M, 10M, and 100M rows and tested eight benchmark types: five query performance benchmarks (where both systems compete) and three capability benchmarks (operations Elasticsearch cannot perform).

\textbf{Third}, analyze when each system is appropriate. Beyond raw performance, we consider factors like SQL capability, operational complexity, and use case fit.

\subsection{Significance}

This study is relevant for organizations dealing with:

\begin{itemize}
    \item Time-series data requiring aggregations over time windows
    \item Large-scale analytics with billions of rows
    \item Complex SQL operations including JOINs and subqueries
    \item Regulated industries requiring HIPAA or GDPR compliance
    \item Cost-sensitive environments where storage and compute costs matter
\end{itemize}

\section{Background Research}

\subsection{Columnar Storage vs Doc\_Values}

Both systems use columnar-style storage for analytics, but with different implementations.

\textbf{ClickHouse} stores each column in separate files with heavy compression. When running \texttt{SELECT AVG(cost) FROM events}, it reads only the \texttt{cost} column. ClickHouse uses vectorized query execution, processing data in batches that leverage CPU SIMD instructions \cite{clickhouse2024architecture}.

\textbf{Elasticsearch} stores documents in inverted indexes for search, but also maintains \texttt{doc\_values}---a columnar structure stored alongside the inverted index. For aggregations, Elasticsearch reads from doc\_values rather than the document source, enabling efficient column-oriented access \cite{elasticsearch2024docs}. This dual structure (inverted index + doc\_values) explains both its search capabilities and competitive aggregation performance.

\subsection{Query Processing}

Elasticsearch's aggregation framework is highly optimized. When executing a terms aggregation with nested metrics, it:
\begin{enumerate}
    \item Uses the inverted index to identify matching documents (if filtered)
    \item Reads only required columns from doc\_values
    \item Processes aggregations in a single pass with efficient memory structures
    \item Caches results for repeated queries
\end{enumerate}

ClickHouse processes queries by scanning compressed column files, applying vectorized operations, and aggregating results. For simple aggregations, both approaches are efficient, but Elasticsearch's pre-indexed structure can provide faster access for common patterns.

\subsection{The mpathic Case Study}

Mpathic's migration provides real-world context. Their challenges with Elasticsearch included:

\begin{itemize}
    \item \textbf{No JOINs}: Data had to be pulled into local databases just to run aggregations---described as ``a really miserable experience''
    \item \textbf{Infrastructure overhead}: Each experiment required spinning up EC2 instances and rebuilding pandas environments (10+ minutes before actual work)
    \item \textbf{Developer productivity}: Engineers spent approximately 60\% of their time just running data jobs
\end{itemize}

After migrating to ClickHouse Cloud, they achieved:

\begin{itemize}
    \item Pipeline execution reduced from 15 minutes to 4 minutes (3.75x faster)
    \item Eliminated EC2 instances entirely---queries run directly in ClickHouse
    \item ClickHouse became ``the backbone of all our ML infrastructure''
\end{itemize}

The key insight: mpathic didn't migrate because Elasticsearch was slow at aggregations. They migrated because Elasticsearch \textit{cannot perform JOINs}, and their data scientists needed to join patient data with events for ML experiments \cite{mpathic2024case}.

\section{Methodology}

\subsection{Dataset}

We generated synthetic healthcare data with the following schema:

\textbf{Medical Events Table:}
\begin{itemize}
    \item \texttt{event\_id}: UUID
    \item \texttt{patient\_id}: Integer (foreign key)
    \item \texttt{timestamp}: DateTime
    \item \texttt{department}: String (Cardiology, Emergency, etc.)
    \item \texttt{severity}: Enum (Critical, High, Medium, Low)
    \item \texttt{event\_type}: String (Surgery, Emergency Visit, etc.)
    \item \texttt{cost\_usd}: Decimal
    \item \texttt{duration\_minutes}: Integer
\end{itemize}

\textbf{Patients Table:}
\begin{itemize}
    \item \texttt{patient\_id}: Integer (primary key)
    \item \texttt{primary\_condition}: String (Diabetes, Hypertension, etc.)
    \item \texttt{insurance\_type}: String (Private, Medicare, etc.)
\end{itemize}

We created three datasets: 1M rows (small hospital), 10M rows (regional health network), and 100M rows (approaching national scale).

\subsection{Infrastructure}

\textbf{ClickHouse}: Deployed on ClickHouse Cloud with MergeTree engine and LZ4 compression.

\textbf{Elasticsearch}: Deployed on Elasticsearch Cloud with 3 shards, 1 replica, and explicit field type mappings with doc\_values enabled.

Both used managed cloud services to reflect realistic deployment scenarios.

\subsection{Benchmark Categories}

We designed two categories of benchmarks to separate \textit{performance} from \textit{capability}:

\textbf{Query Performance (5 benchmarks)} --- Operations both systems can execute:
\begin{enumerate}
    \item \textbf{Simple Aggregation}: \texttt{GROUP BY department} with COUNT and AVG
    \item \textbf{Time-Series Analysis}: Daily aggregations with date bucketing
    \item \textbf{Full-Text Search}: Pattern matching on event types
    \item \textbf{Top-N Query}: \texttt{ORDER BY cost DESC LIMIT 10}
    \item \textbf{Multi-Metric Dashboard}: 6 metrics grouped by department
\end{enumerate}

\textbf{Capability Comparison (3 benchmarks)} --- Operations Elasticsearch cannot perform:
\begin{enumerate}
    \item \textbf{Patient-Event JOIN}: Join patients with events by condition
    \item \textbf{Cost by Condition}: Healthcare costs per patient condition (requires JOIN)
    \item \textbf{Anomaly Detection}: Events above average cost (requires subquery)
\end{enumerate}

Each query ran 5 times after 2 warm-up runs. We measured average execution time, min/max range, and standard deviation.

\section{Results}

\subsection{Query Performance}

\begin{table}[H]
\centering
\caption{Query Performance Comparison (100M rows)}
\begin{tabular}{lrrr}
\toprule
\textbf{Query Type} & \textbf{ClickHouse (ms)} & \textbf{Elasticsearch (ms)} & \textbf{ES Speedup} \\
\midrule
Simple Aggregation & 689 & 34 & 20.5x \\
Time-Series Analysis & 442 & 50 & 8.8x \\
Full-Text Search & 653 & 36 & 18.3x \\
Top-N Query & 330 & 43 & 7.7x \\
Multi-Metric Dashboard & 2,445 & 102 & 24.0x \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Elasticsearch wins all 5 query benchmarks}, with speedups ranging from 7.7x to 24x on the 100M row dataset.

Key findings:

\textbf{Multi-Metric Dashboard} showed Elasticsearch's largest advantage (24x). The aggregation framework efficiently computes multiple metrics (COUNT, cardinality, SUM, AVG, filtered count) in a single pass over doc\_values.

\textbf{Simple Aggregation} demonstrated 20x faster performance. Elasticsearch's terms aggregation with nested avg is highly optimized for this common pattern.

\textbf{Full-Text Search} showed 18x advantage, as expected. Elasticsearch's inverted index handles text matching efficiently, while ClickHouse's LIKE operator requires full column scans.

\subsection{Scaling Behavior}

\begin{table}[H]
\centering
\caption{Elasticsearch Speedup Across Dataset Sizes}
\begin{tabular}{lrrr}
\toprule
\textbf{Query Type} & \textbf{1M rows} & \textbf{10M rows} & \textbf{100M rows} \\
\midrule
Simple Aggregation & 2.3x & 3.7x & 20.5x \\
Time-Series Analysis & 1.4x & 1.8x & 8.8x \\
Full-Text Search & 1.9x & 3.6x & 18.3x \\
Top-N Query & 2.0x & 2.6x & 7.7x \\
Multi-Metric Dashboard & 1.2x & 3.0x & 24.0x \\
\bottomrule
\end{tabular}
\end{table}

Elasticsearch's advantage \textit{increases} with dataset size. At 1M rows, speedups are modest (1.2x--2.3x). At 100M rows, they become substantial (7.7x--24x). This suggests Elasticsearch's doc\_values and aggregation caching scale better than ClickHouse's vectorized scans for these query patterns.

\subsection{Capability Comparison}

\begin{table}[H]
\centering
\caption{Capability Benchmarks (100M rows)}
\begin{tabular}{lrp{6cm}}
\toprule
\textbf{Operation} & \textbf{ClickHouse (ms)} & \textbf{Elasticsearch} \\
\midrule
Patient-Event JOIN & 2,132 & \textit{Not possible} --- requires denormalization or application-side joins \\
Cost by Condition & 2,136 & \textit{Not possible} --- cannot join patient metadata with events \\
Anomaly Detection & 1,220 & \textit{Not possible} --- requires two queries and application logic \\
\bottomrule
\end{tabular}
\end{table}

\textbf{ClickHouse wins all 3 capability benchmarks by default} because Elasticsearch cannot execute these operations.

For the JOIN operations, Elasticsearch users must either:
\begin{itemize}
    \item \textbf{Denormalize data}: Duplicate patient information into every event document, increasing storage and update complexity
    \item \textbf{Application-side joins}: Run multiple queries and join results in application code, adding latency and complexity
\end{itemize}

For subqueries, Elasticsearch requires two separate queries: one to compute the average, then a second with that value as a filter. This doubles latency and requires additional application logic.

\subsection{Validation Against mpathic's Results}

Our findings align with mpathic's experience:

\begin{itemize}
    \item \textbf{Capability gap}: Our benchmarks confirm that JOIN and subquery operations are impossible in Elasticsearch---exactly what drove mpathic's migration
    \item \textbf{Pipeline improvements}: mpathic's 3.75x faster pipelines (15 min to 4 min) align with our finding that ClickHouse can execute complex analytical queries that Elasticsearch cannot
    \item \textbf{Infrastructure simplification}: By supporting JOINs natively, ClickHouse eliminated mpathic's need for separate EC2 instances and pandas environments
\end{itemize}

\section{Discussion}

\subsection{Understanding the Results}

Our benchmarks reveal a nuanced picture:

\textbf{For queries both systems can execute}, Elasticsearch is significantly faster (8--24x) due to its optimized doc\_values and aggregation framework. This contradicts the common assumption that columnar databases always outperform document stores on analytics.

\textbf{For queries requiring JOINs or subqueries}, ClickHouse wins by default because Elasticsearch cannot execute them at all. This is a capability gap, not a performance gap.

\subsection{Why Elasticsearch Wins on Aggregations}

Several factors contribute to Elasticsearch's query performance:

\begin{enumerate}
    \item \textbf{Doc\_values}: Pre-built columnar structure optimized for aggregations
    \item \textbf{Aggregation caching}: Repeated queries benefit from cached results
    \item \textbf{Optimized data structures}: Global ordinals for terms aggregations reduce memory and CPU usage
    \item \textbf{Shard-level parallelism}: Aggregations run in parallel across shards with efficient merging
\end{enumerate}

ClickHouse's vectorized execution is powerful but requires scanning and decompressing column files for each query. For simple aggregations, Elasticsearch's pre-indexed approach provides faster access.

\subsection{Why ClickHouse Won for mpathic}

Despite Elasticsearch's query speed advantage, mpathic chose ClickHouse because:

\begin{enumerate}
    \item \textbf{JOINs are essential for ML}: Data scientists need to join patient demographics, conditions, and events for feature engineering
    \item \textbf{SQL compatibility}: Standard SQL enables faster development and broader tool compatibility
    \item \textbf{Single system}: No need for separate infrastructure to run analytical queries
\end{enumerate}

The lesson: \textit{capability trumps performance}. A system that executes your queries in 2 seconds beats a system that cannot execute them at all, regardless of how fast the latter runs other queries.

\subsection{Elasticsearch's Unique Strengths}

While ClickHouse can technically perform most operations, Elasticsearch has practical advantages that ClickHouse cannot easily replicate:

\textbf{Advanced Full-Text Search Features:}
\begin{itemize}
    \item \textbf{Fuzzy matching}: ``hsopital'' automatically matches ``hospital''
    \item \textbf{Synonyms}: ``heart attack'' matches ``myocardial infarction''
    \item \textbf{Stemming}: ``running'' matches ``run'', ``ran'', ``runs''
    \item \textbf{Relevance scoring (BM25)}: Results ranked by match quality
    \item \textbf{Highlighting}: Shows which parts of text matched the query
\end{itemize}

ClickHouse has basic full-text indexes, but lacks the linguistic sophistication of Lucene-based search.

\textbf{Real-Time Document Updates:}
Elasticsearch can update individual documents instantly. ClickHouse is optimized for batch inserts; single-row updates require expensive mutations that rewrite entire data parts.

\textbf{Nested/Hierarchical Documents:}
Elasticsearch natively handles JSON arrays and nested objects with dedicated query syntax. ClickHouse requires flattening data or using Array columns with more complex query patterns.

\textbf{Ecosystem Integration:}
Kibana provides powerful visualization out of the box. Elasticsearch includes built-in anomaly detection and index lifecycle management. ClickHouse requires external tools for equivalent functionality.

\subsection{When to Choose Each System}

\textbf{Choose Elasticsearch when:}
\begin{itemize}
    \item Full-text search with fuzzy matching, synonyms, or relevance scoring is needed
    \item Queries involve single-table aggregations on denormalized data
    \item Real-time document updates are required (not batch inserts)
    \item Data is naturally hierarchical with nested JSON structures
    \item Query patterns are repetitive (benefiting from caching)
    \item Kibana dashboards or built-in ML features are valuable
\end{itemize}

\textbf{Choose ClickHouse when:}
\begin{itemize}
    \item JOINs across tables are required
    \item Subqueries or complex SQL are needed
    \item Data is normalized across multiple tables
    \item SQL compatibility matters (BI tools, data scientists)
    \item Storage efficiency and compression are critical
    \item High-volume batch ingestion is the primary write pattern
\end{itemize}

\subsection{Limitations}

Our study has limitations:

\begin{itemize}
    \item Used managed cloud services with default configurations
    \item Did not test ClickHouse's full-text search capabilities
    \item Synthetic data may not capture all production patterns
    \item Did not measure actual storage sizes or ingestion speeds
    \item Single deployment configuration per system
\end{itemize}

Future work could explore ClickHouse's materialized views (which could match Elasticsearch's aggregation speed) and Elasticsearch's runtime fields for ad-hoc calculations.

\section{Conclusion}

Database selection requires understanding both performance and capability. Our benchmarks demonstrate:

\textbf{Query Performance}: Elasticsearch delivers 8--24x faster aggregations due to its optimized doc\_values and aggregation framework. For single-table analytics, Elasticsearch is surprisingly competitive---and often superior---to columnar databases.

\textbf{Query Capability}: ClickHouse supports JOINs and subqueries that Elasticsearch fundamentally cannot execute. For normalized data requiring multi-table queries, ClickHouse is the only viable choice.

The mpathic case study illustrates this trade-off. Their engineers spent 60\% of their time on data jobs because Elasticsearch couldn't join patient data with events. After migrating to ClickHouse, they achieved 3.75x faster pipelines---not because ClickHouse runs aggregations faster, but because it can run the queries they actually needed.

The key insight: \textit{architecture determines capability, not just performance}. You cannot make Elasticsearch perform JOINs through optimization, just as you cannot make ClickHouse match inverted index performance on text search. Understanding these fundamental capabilities enables informed decisions that align technical requirements with business needs.

For healthcare organizations, financial services, and other domains with normalized data models requiring multi-table analysis, ClickHouse's SQL capabilities provide essential functionality. For search applications and single-table analytics with denormalized data, Elasticsearch's performance advantages make it the better choice.

\section*{Acknowledgments}

We thank the ClickHouse and Elasticsearch communities for their documentation and support. The mpathic case study provided valuable real-world context. We also acknowledge Western University for supporting this research.

\begin{thebibliography}{9}

\bibitem{clickhouse2024architecture}
ClickHouse Inc. (2024).
\textit{ClickHouse Documentation: Architecture Overview.}
Retrieved from \url{https://clickhouse.com/docs/en/development/architecture}

\bibitem{clickhouse2024compression}
ClickHouse Inc. (2024).
\textit{ClickHouse Documentation: Compression in ClickHouse.}
Retrieved from \url{https://clickhouse.com/docs/en/data-compression/compression-in-clickhouse}

\bibitem{mpathic2024case}
ClickHouse Inc. (2024).
\textit{How mpathic built better ML workflows by switching from Elasticsearch to ClickHouse Cloud.}
Retrieved from \url{https://clickhouse.com/blog/mpathic-better-ml-elastic-to-clickhouse-migration}

\bibitem{elasticsearch2024docs}
Elastic N.V. (2024).
\textit{Elasticsearch Guide [8.x]: Doc Values.}
Retrieved from \url{https://www.elastic.co/guide/en/elasticsearch/reference/current/doc-values.html}

\bibitem{elasticsearch2024aggs}
Elastic N.V. (2024).
\textit{Elasticsearch Guide [8.x]: Aggregations.}
Retrieved from \url{https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html}

\end{thebibliography}

\end{document}
